# Cascaded Agent Loops in Windsurf: Research & Architecture Proposal

## Executive Summary

Windsurf **already has** the core building blocks for near-intervention-free cascaded agent loops. The key primitives are: **Git Worktrees** (parallel isolated workspaces), **Simultaneous Cascades** (multiple agent sessions), **Workflows** (sequenced multi-step instructions), **Skills** (bundled multi-step task knowledge), **Cascade Hooks** (lifecycle event scripting), **Auto-Execution modes** (Turbo mode), **Auto-Continue**, and **Plan Mode**. What's missing is a **spec-driven orchestration layer** that ties them together into a fully autonomous loop. This document maps out what exists, what's possible today, and a practical architecture for building it.

---

## 1. What Windsurf Already Provides

### 1.1 Git Worktrees (Native, Wave 13+)

- **What**: Each Cascade conversation can run in its own git worktree â€” a full copy of the repo on a separate branch, isolated from the main workspace.
- **How**: Toggle "Worktree" mode in the bottom-right of the Cascade input at conversation start.
- **Location**: `~/.windsurf/worktrees/<repo_name>/<random_name>`
- **Merge back**: After Cascade finishes, click "Merge" to incorporate changes into the main workspace.
- **Setup hook**: `post_setup_worktree` hook in `.windsurf/hooks.json` copies `.env`, installs deps, etc.
- **Limit**: Up to 20 worktrees per workspace; oldest auto-cleaned.
- **Key implication**: Multiple Cascades can work on different features/tasks in parallel without file conflicts.

### 1.2 Simultaneous Cascades

- Multiple Cascade sessions can run at the same time (navigate via dropdown in Cascade panel).
- **Warning**: If two Cascades edit the same file without worktrees, edits can race and fail.
- **Best practice**: Combine with worktrees for true parallel isolation.

### 1.3 Workflows (`.windsurf/workflows/*.md`)

- Structured sequence of steps invoked via `/workflow-name` in Cascade.
- Workflows can **call other workflows** (`/workflow-1` can say "Call `/workflow-2`").
- Steps are processed sequentially by Cascade.
- `// turbo` annotation above a step allows auto-run of that step's command.
- Max 12,000 characters per workflow file.
- Can be generated by Cascade itself.

### 1.4 Skills (`.windsurf/skills/<name>/SKILL.md`)

- Bundles of instructions + supporting files (checklists, templates, scripts) for complex multi-step tasks.
- **Auto-invoked** when Cascade detects relevance, or manually via `@skill-name`.
- Progressive disclosure: Cascade reads skill content only when relevant.
- Can include reference scripts, config templates, rollback procedures, etc.

### 1.5 Cascade Hooks (`.windsurf/hooks.json`)

Lifecycle hooks that fire shell commands at key points:

| Hook | Timing | Can Block? | Use Case |
|------|--------|------------|----------|
| `pre_read_code` | Before file read | Yes (exit 2) | Access control |
| `post_read_code` | After file read | No | Logging |
| `pre_write_code` | Before file write | Yes (exit 2) | Validation |
| `post_write_code` | After file write | No | Auto-format, lint, test |
| `pre_run_command` | Before terminal cmd | Yes (exit 2) | Security |
| `post_run_command` | After terminal cmd | No | Logging |
| `pre_user_prompt` | Before processing prompt | Yes (exit 2) | Policy enforcement |
| `post_cascade_response` | After Cascade responds | No | Audit, trigger next step |
| `pre_mcp_tool_use` | Before MCP call | Yes (exit 2) | Validation |
| `post_mcp_tool_use` | After MCP call | No | Logging |
| `post_setup_worktree` | After worktree created | No | Env setup |

**Key insight**: `post_cascade_response` and `post_write_code` hooks can be used to trigger external orchestration scripts that feed the next prompt back into Cascade.

### 1.6 Auto-Execution Modes

| Level | Behavior |
|-------|----------|
| **Disabled** | All commands need manual approval |
| **Allowlist Only** | Only allow-listed commands auto-run |
| **Auto** | Cascade judges safety; risky commands still need approval |
| **Turbo** | All commands auto-execute (except deny-listed) |

### 1.7 Auto-Continue

- When Cascade hits its 20-tool-call limit per prompt, it can **automatically continue** from where it left off (costs additional prompt credits).
- Configurable in settings.

### 1.8 Plan Mode

- Cascade explores codebase, asks clarifying questions, presents options, then generates a detailed plan in a Markdown file.
- Click "Implement" to switch to Code mode and execute the plan.
- A background **planning agent** continuously refines the long-term plan while the execution model takes short-term actions.

### 1.9 AGENTS.md

- Context-aware instructions that automatically apply based on file location.
- Scoped per directory â€” Cascade discovers and follows them automatically.

### 1.10 Queued Messages

- While Cascade is working, you can queue follow-up messages that execute in order once the current task completes.

---

## 2. What a Spec-Driven Auto-Loop Looks Like

The industry pattern (from SpecKit/Ralph, Addy Osmani's workflow, ThoughtWorks SDD) is:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  SPEC PHASE                      â”‚
â”‚  spec.md â†’ tasks.md â†’ architecture decisions     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ITERATION LOOP                      â”‚
â”‚  For each task in tasks.md:                      â”‚
â”‚    1. Read context (spec, progress, codebase)    â”‚
â”‚    2. Pick next uncompleted task                 â”‚
â”‚    3. Implement in isolated worktree             â”‚
â”‚    4. Run tests / lint / build                   â”‚
â”‚    5. If fail â†’ fix loop (up to N retries)       â”‚
â”‚    6. Commit with descriptive message            â”‚
â”‚    7. Update progress.txt                        â”‚
â”‚    8. Repeat until all tasks done                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MERGE & REVIEW                      â”‚
â”‚  Merge worktree â†’ PR â†’ human review             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ralph SpecKit Reference

Ralph (github.com/merllinsbeard/ralph-speckit) implements this for Claude Code:
1. Reads `tasks.md` + `progress.txt` + project docs
2. Picks ONE task (first uncompleted with deps met)
3. Implements following project patterns
4. Verifies (tests, lint, build)
5. Commits
6. Updates progress
7. Repeats until `<promise>COMPLETE</promise>`

---

## 3. How to Build This in Windsurf Today

### 3.1 Architecture: Spec-Driven Cascaded Loop

```
.windsurf/
â”œâ”€â”€ workflows/
â”‚   â”œâ”€â”€ spec-loop.md          # Main orchestration workflow
â”‚   â”œâ”€â”€ implement-task.md     # Single task implementation
â”‚   â”œâ”€â”€ verify-task.md        # Test/lint/build verification
â”‚   â””â”€â”€ merge-and-review.md   # Final merge workflow
â”œâ”€â”€ skills/
â”‚   â””â”€â”€ spec-driven-dev/
â”‚       â”œâ”€â”€ SKILL.md           # Auto-invoked skill for SDD
â”‚       â”œâ”€â”€ spec-template.md   # Spec template
â”‚       â””â”€â”€ task-template.md   # Task breakdown template
â”œâ”€â”€ hooks.json                 # Lifecycle hooks
â””â”€â”€ rules/
    â””â”€â”€ spec-loop-rules.md     # Global rules for loop behavior
```

### 3.2 The Main Loop Workflow (`/spec-loop`)

```markdown
---
description: Run a spec-driven autonomous development loop
---

## Spec-Driven Development Loop

1. Read `specs/spec.md` and `specs/tasks.md` to understand the full project scope.

2. Read `specs/progress.txt` to understand what has already been completed.

3. Identify the NEXT uncompleted task from `tasks.md` whose dependencies are all met.
   If all tasks are complete, summarize the work and stop.

// turbo
4. Create a named checkpoint: "Before task: [task name]"

5. Implement the task following the patterns established in the codebase.
   - Read relevant existing code first
   - Make minimal, focused changes
   - Follow the project's coding conventions

// turbo
6. Run the project's test suite: `npm test` (or equivalent from spec)

7. If tests fail, analyze the failure and fix. Retry up to 3 times.
   If still failing after 3 retries, update `specs/progress.txt` with
   "BLOCKED: [task name] - [reason]" and move to the next task.

// turbo
8. Run linting: `npm run lint` (or equivalent)

// turbo
9. Commit changes: `git add -A && git commit -m "feat: [task description]"`

10. Update `specs/progress.txt`:
    - Mark the task as DONE with timestamp
    - Note any learnings or decisions made

11. Call `/spec-loop` to continue with the next task.
```

### 3.3 Parallel Task Execution (Multiple Worktree Cascades)

For independent tasks, you can launch multiple Cascade sessions in worktree mode:

1. **Cascade 1** (Worktree): "Implement Task 3 - User authentication" â†’ `/implement-task`
2. **Cascade 2** (Worktree): "Implement Task 4 - Dashboard UI" â†’ `/implement-task`
3. **Cascade 3** (Worktree): "Implement Task 5 - API endpoints" â†’ `/implement-task`

Each runs in its own worktree, isolated branch. Merge back when done.

**Limitation**: You must manually launch each parallel Cascade and assign it a task. There is no built-in "fan-out" orchestrator that auto-spawns parallel Cascades.

### 3.4 Hooks for Automation Glue

```json
{
  "hooks": {
    "post_setup_worktree": [
      {
        "command": "bash $ROOT_WORKSPACE_PATH/hooks/setup_worktree.sh",
        "show_output": true
      }
    ],
    "post_write_code": [
      {
        "command": "bash .windsurf/hooks/auto-format.sh",
        "show_output": false
      }
    ],
    "post_cascade_response": [
      {
        "command": "python3 .windsurf/hooks/log_progress.py",
        "show_output": false
      }
    ]
  }
}
```

### 3.5 Settings for Maximum Autonomy

| Setting | Value | Why |
|---------|-------|-----|
| Auto-Execution Level | **Turbo** | All commands auto-execute |
| Auto-Continue | **Enabled** | Cascade continues past 20-tool limit |
| Worktree Mode | **On** (per Cascade) | Isolation for parallel work |

---

## 4. Current Limitations & Gaps

### 4.1 No True "Outer Loop" Orchestrator

Windsurf's workflow system is **single-threaded within a Cascade session**. The recursive `/spec-loop` calling itself is the closest to an auto-loop, but:
- Each "continue" or recursive workflow call costs prompt credits
- Context window fills up over long sessions â€” Cascade may lose track of earlier context
- No built-in mechanism to automatically spawn N parallel Cascades from a task list

### 4.2 No Programmatic Cascade API

There is no CLI or API to programmatically:
- Start a new Cascade session with a specific prompt
- Feed prompts into an existing Cascade session
- Query Cascade session status

This means you can't build an external orchestrator (like Ralph) that drives Windsurf Cascades programmatically. The `post_cascade_response` hook can *observe* but not *inject* new prompts.

### 4.3 Worktree Merge is Manual

After a worktree Cascade finishes, merging back requires clicking "Merge" in the UI. There's no auto-merge or auto-PR creation.

### 4.4 No Inter-Cascade Communication

Parallel Cascades can't communicate with each other. There's no shared state, message passing, or coordination protocol between simultaneous sessions.

### 4.5 Context Window Degradation

Long-running loops will eventually degrade as the context window fills. Cascade's planning agent helps, but very long autonomous runs (50+ tasks) will likely need session restarts.

---

## 5. Practical Strategies to Maximize Autonomy Today

### Strategy 1: Recursive Workflow + Queued Messages

1. Write a `/spec-loop` workflow (as above)
2. Set Auto-Execution to **Turbo**, enable **Auto-Continue**
3. Invoke `/spec-loop` in a worktree Cascade
4. Queue a "continue" message as insurance
5. Cascade will loop through tasks, committing each one

**Intervention needed**: Only when Cascade gets stuck, runs out of context, or hits a genuinely ambiguous decision.

### Strategy 2: Parallel Worktree Fan-Out (Manual Launch)

1. Analyze `tasks.md` to identify independent task clusters
2. Launch N Cascade sessions, each in worktree mode
3. Assign each a task cluster via `/implement-task`
4. Let them run in parallel with Turbo mode
5. Merge results back sequentially

**Intervention needed**: Launching each Cascade, assigning tasks, merging.

### Strategy 3: Hooks + External Script (Advanced)

Use `post_cascade_response` hook to:
1. Parse Cascade's response for completion signals
2. Log progress to `progress.txt`
3. Trigger notifications (Slack, email) when tasks complete or block

This doesn't close the loop (can't inject prompts), but gives you **monitoring** and **progress tracking** without watching the IDE.

### Strategy 4: Plan Mode â†’ Implement Pipeline

1. Start in **Plan Mode**: "Read spec.md and create a detailed implementation plan"
2. Cascade explores codebase, asks questions, generates plan
3. Click "Implement" â†’ Cascade switches to Code mode and executes
4. Combined with Auto-Continue + Turbo, this is quite autonomous

---

## 6. Comparison with Other Tools

| Capability | Windsurf | Claude Code + Ralph | Cursor | Codex |
|-----------|----------|-------------------|--------|-------|
| Parallel agents | âœ… Worktrees + Simultaneous Cascades | âœ… Multiple terminals | âŒ Single agent | âœ… Worktrees |
| Spec-driven loop | ğŸŸ¡ Via workflows (manual setup) | âœ… Ralph automates | âŒ Manual | âœ… Native |
| Auto-execution | âœ… Turbo mode | âœ… `--dangerously-skip-permissions` | ğŸŸ¡ Limited | âœ… Sandboxed |
| Lifecycle hooks | âœ… Rich hook system | âŒ None | âŒ None | âŒ None |
| Programmatic API | âŒ No | âœ… CLI-driven | âŒ No | âœ… CLI + API |
| Auto-continue | âœ… Built-in | âœ… Inherent (CLI) | ğŸŸ¡ Manual | âœ… Inherent |
| Inter-agent comms | âŒ No | ğŸŸ¡ Via filesystem | âŒ No | ğŸŸ¡ Via filesystem |
| Plan â†’ Execute | âœ… Plan Mode | ğŸŸ¡ Manual | ğŸŸ¡ Manual | âŒ No |

**Windsurf's unique advantage**: The hooks system + worktrees + workflows + skills combination is the most composable. What it lacks is a CLI/API to close the outer loop programmatically.

---

## 7. Recommended Architecture for This Project

### Phase 1: Spec-Driven Workflow (Works Today)

Create the workflow/skill/hook infrastructure in this repo:

```
specs/
â”œâ”€â”€ spec.md              # Project specification
â”œâ”€â”€ tasks.md             # Ordered task list with dependencies
â””â”€â”€ progress.txt         # Auto-updated progress log

.windsurf/
â”œâ”€â”€ workflows/
â”‚   â”œâ”€â”€ spec-loop.md     # Main autonomous loop
â”‚   â”œâ”€â”€ plan-spec.md     # Generate spec from requirements
â”‚   â””â”€â”€ review-merge.md  # Review and merge workflow
â”œâ”€â”€ skills/
â”‚   â””â”€â”€ spec-dev/
â”‚       â””â”€â”€ SKILL.md     # SDD skill with templates
â”œâ”€â”€ hooks.json           # Worktree setup + progress logging
â””â”€â”€ rules/
    â””â”€â”€ autonomy.md      # Rules for autonomous behavior
```

### Phase 2: Parallel Execution Pattern

For projects with independent modules:
1. Use Plan Mode to decompose into independent task clusters
2. Launch parallel worktree Cascades (one per cluster)
3. Each runs `/spec-loop` on its cluster
4. Merge back via `/review-merge`

### Phase 3: External Orchestrator (Future / Requires API)

If/when Windsurf exposes a CLI or API:
- Build a `ralph`-like shell script that:
  - Reads `tasks.md`
  - Spawns Cascade sessions via API
  - Monitors via hooks
  - Merges via git
  - Loops until complete

---

## 8. Key Takeaways

1. **Windsurf CAN do spec-driven auto-loops today** using recursive workflows + Turbo mode + Auto-Continue + worktrees. It's not zero-intervention, but it's close to ~90% autonomous for well-specified tasks.

2. **Parallel execution is real** via simultaneous Cascades in worktree mode, but requires manual fan-out (launching each session).

3. **The missing piece** is a programmatic API/CLI to drive Cascade sessions externally, which would enable true Ralph-style outer-loop orchestration.

4. **Hooks are the secret weapon** â€” they provide the observability and automation glue that no other AI IDE offers at this level.

5. **For maximum autonomy today**: Turbo mode + Auto-Continue + recursive workflows + worktrees + well-structured specs = the closest thing to "intervention-free" that Windsurf supports.

---

## 9. Additional Research (Round 2)

### 9.1 Windsurf CLI Status

**Finding**: Windsurf has a basic CLI (`windsurf .` to open a folder, `windsurf --goto file:line:col`), inherited from VS Code OSS. However, there is **no headless mode, no programmatic Cascade API, and no way to inject prompts from the command line**.

- `windsurf .` â€” opens a folder in the IDE
- `windsurf --diff file1 file2` â€” opens diff view
- `windsurf --goto file:line:col` â€” opens file at position
- Standard VS Code CLI flags work (extensions, settings, etc.)

**What's missing**:
- No `windsurf cascade --prompt "..."` or equivalent
- No API endpoint for Cascade (the Windsurf API is analytics/admin only)
- No headless/daemon mode for running Cascade without the GUI

**Implication**: You cannot build an external orchestrator that programmatically drives Cascade sessions. The mailbox protocol (file-based coordination) is the best available workaround.

**Comparison**: Claude Code has full CLI + agent teams (`claude --print`, subagents, tmux-based multi-session). OpenAI Codex has a CLI + API. Windsurf is GUI-first.

### 9.2 File-Based Inter-Session Communication

**Finding**: Cascade has **real-time awareness** of file changes in the workspace. This is a unique capability that can be exploited for inter-session coordination.

#### How It Works

When one Cascade session writes a file, another session in the same workspace (or a worktree that shares the git history) can detect the change. Combined with workflows/rules that instruct Cascade to check specific files, this creates a primitive message-passing system.

#### The Mailbox Protocol

We designed a file-based coordination protocol at `.windsurf/mailbox/`:

```
.windsurf/mailbox/
â”œâ”€â”€ board/status.json    # Shared state visible to all sessions
â”œâ”€â”€ board/claims.json    # Task claim registry (prevents double-work)
â”œâ”€â”€ inbox/<session>/     # Messages TO a session
â””â”€â”€ outbox/<session>/    # Completion signals FROM a session
```

**Three coordination patterns**:

1. **Lead-Worker**: A lead session assigns tasks by writing to `inbox/worker-N/`. Workers check their inbox, implement, write completion to `outbox/worker-N/`. Lead watches outbox.

2. **Claim Board**: All sessions read `board/claims.json`. Before starting a task, a session writes a claim. Other sessions check before claiming the same task. Self-organizing.

3. **Pipeline**: Session A completes Phase 1, writes handoff to `inbox/session-b/`. Session B picks up Phase 2. Sequential handoff chain.

**Limitations**:
- No true file locking (use claim-then-verify pattern)
- Sessions must be instructed to poll mailbox files (not automatic)
- Each parallel session must be launched manually
- Worktree sessions have separate filesystem copies â€” mailbox works best in the main workspace or via git commits

#### Comparison with Claude Code Agent Teams

Claude Code's agent teams use:
- `~/.claude/teams/{team-name}/config.json` â€” team config
- `~/.claude/tasks/{team-name}/` â€” shared task list
- Automatic message delivery between teammates
- Idle notifications when teammates finish
- tmux sessions for parallel execution

Our mailbox protocol is a manual approximation of this, constrained by Windsurf's lack of a programmatic API.

### 9.3 Multi-Spec Architecture

**Rationale**: Large projects benefit from decomposition into independent specs, each with its own task list and progress tracking. This enables:

- **Parallel spec execution**: Different Cascade sessions (in worktrees) can implement different specs simultaneously
- **Team decomposition**: Assign specs to different team members or sessions
- **Incremental delivery**: Complete and merge one spec while others are still in progress
- **Reduced context window pressure**: Each spec's task list is smaller, keeping Cascade focused

**Structure**:
```
specs/
â”œâ”€â”€ index.md           # Registry of all specs
â”œâ”€â”€ templates/         # Reusable templates
â”œâ”€â”€ auth/              # Auth module spec
â”‚   â”œâ”€â”€ spec.md
â”‚   â”œâ”€â”€ tasks.md
â”‚   â””â”€â”€ progress.txt
â”œâ”€â”€ api/               # API spec
â”‚   â”œâ”€â”€ spec.md
â”‚   â”œâ”€â”€ tasks.md
â”‚   â””â”€â”€ progress.txt
â””â”€â”€ dashboard/         # Dashboard spec
    â”œâ”€â”€ spec.md
    â”œâ”€â”€ tasks.md
    â””â”€â”€ progress.txt
```

All workflows now accept a spec name parameter: `/spec-loop auth`, `/implement-task api T3`, etc.

### 9.4 Can Sessions Drive Other Sessions?

**Short answer**: Not directly. But there are workarounds:

| Approach | Feasibility | Notes |
|----------|-------------|-------|
| Cascade A writes file, Cascade B reads it | âœ… Works | Requires B to be instructed to watch for the file |
| Hook triggers external script | âœ… Works | `post_cascade_response` can run any script, but can't inject prompts back |
| Queued messages | âœ… Works (same session) | Queue follow-up prompts while Cascade is working |
| Workflow calls workflow | âœ… Works (same session) | `/spec-loop` can call `/verify-all` etc. |
| MCP server as coordination hub | ğŸŸ¡ Possible | Custom MCP server could maintain state, but still can't inject prompts |
| External script opens Windsurf | âŒ No | `windsurf .` opens IDE but can't send prompts to Cascade |

**Best current approach**: Use the mailbox protocol + workflows that instruct each session to check its inbox. The lead session writes assignments; worker sessions are launched manually with instructions to check `inbox/<name>/` for their task.

### 9.5 Future Possibilities

If Windsurf adds any of these, the framework becomes significantly more powerful:

1. **Cascade CLI** (`windsurf cascade --prompt "..." --worktree`) â€” enables true outer-loop orchestration
2. **Inter-Cascade messaging** â€” native message passing between simultaneous sessions
3. **Cascade API** â€” REST/WebSocket API for programmatic session control
4. **Hook prompt injection** â€” ability for `post_cascade_response` hooks to feed the next prompt back
5. **Workflow triggers** â€” file-watch triggers that auto-invoke workflows when files change
